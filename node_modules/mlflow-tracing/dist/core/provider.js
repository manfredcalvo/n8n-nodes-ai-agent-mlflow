"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeSDK = initializeSDK;
exports.getTracer = getTracer;
exports.flushTraces = flushTraces;
const api_1 = require("@opentelemetry/api");
const mlflow_1 = require("../exporters/mlflow");
const sdk_node_1 = require("@opentelemetry/sdk-node");
const config_1 = require("./config");
const clients_1 = require("../clients");
let sdk = null;
// Keep a reference to the span processor for flushing
let processor = null;
function initializeSDK() {
    if (sdk) {
        sdk.shutdown().catch((error) => {
            console.error('Error shutting down existing SDK:', error);
        });
    }
    try {
        const hostConfig = (0, config_1.getConfig)();
        if (!hostConfig.host) {
            console.warn('MLflow tracking server not configured. Call init() before using tracing APIs.');
            return;
        }
        const client = new clients_1.MlflowClient({
            trackingUri: hostConfig.trackingUri,
            host: hostConfig.host,
            databricksToken: hostConfig.databricksToken
        });
        const exporter = new mlflow_1.MlflowSpanExporter(client);
        processor = new mlflow_1.MlflowSpanProcessor(exporter);
        sdk = new sdk_node_1.NodeSDK({ spanProcessors: [processor] });
        sdk.start();
    }
    catch (error) {
        console.error('Failed to initialize MLflow tracing:', error);
    }
}
function getTracer(module_name) {
    return api_1.trace.getTracer(module_name);
}
/**
 * Force flush all pending trace exports.
 */
async function flushTraces() {
    await processor?.forceFlush();
}
