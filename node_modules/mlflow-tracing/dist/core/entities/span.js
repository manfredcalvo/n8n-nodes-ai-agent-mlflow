"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoOpSpan = exports.LiveSpan = exports.Span = void 0;
exports.createMlflowSpan = createMlflowSpan;
const api_1 = require("@opentelemetry/api");
const constants_1 = require("../constants");
const span_event_1 = require("./span_event");
const span_status_1 = require("./span_status");
const utils_1 = require("../utils");
const json_1 = require("../utils/json");
const trace_manager_1 = require("../trace_manager");
/**
 * MLflow Span class that wraps the OpenTelemetry Span.
 */
class Span {
    /**
     * Create a new MLflowSpan
     * @param span OpenTelemetry span
     */
    constructor(span, is_mutable = false) {
        this._span = span;
        if (is_mutable) {
            this._attributesRegistry = new SpanAttributesRegistry(span);
        }
        else {
            this._attributesRegistry = new CachedSpanAttributesRegistry(span);
        }
    }
    get traceId() {
        return this.getAttribute(constants_1.SpanAttributeKey.TRACE_ID);
    }
    get spanId() {
        return this._span.spanContext().spanId;
    }
    get spanType() {
        return this.getAttribute(constants_1.SpanAttributeKey.SPAN_TYPE);
    }
    /**
     * Get the parent span ID
     */
    get parentId() {
        return this._span.parentSpanContext?.spanId ?? null;
    }
    get name() {
        return this._span.name;
    }
    get startTime() {
        return this._span.startTime;
    }
    get endTime() {
        return this._span.endTime;
    }
    get status() {
        return span_status_1.SpanStatus.fromOtelStatus(this._span.status);
    }
    get inputs() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.getAttribute(constants_1.SpanAttributeKey.INPUTS);
    }
    get outputs() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.getAttribute(constants_1.SpanAttributeKey.OUTPUTS);
    }
    get attributes() {
        return this._attributesRegistry.getAll();
    }
    getAttribute(key) {
        return this._attributesRegistry.get(key);
    }
    get events() {
        return this._span.events.map((event) => {
            const [seconds, nanoseconds] = event.time;
            return new span_event_1.SpanEvent({
                name: event.name,
                attributes: event.attributes,
                timestamp: BigInt(seconds) * 1000000000n + BigInt(nanoseconds)
            });
        });
    }
    /**
     * Convert this span to JSON format (OpenTelemetry format)
     * @returns JSON object representation of the span
     */
    toJson() {
        return {
            trace_id: (0, utils_1.encodeTraceIdToBase64)(this.traceId),
            span_id: (0, utils_1.encodeSpanIdToBase64)(this.spanId),
            // Use empty string for parent_span_id if it is not set, to be consistent with Python implementation.
            parent_span_id: this.parentId ? (0, utils_1.encodeSpanIdToBase64)(this.parentId) : '',
            name: this.name,
            start_time_unix_nano: (0, utils_1.convertHrTimeToNanoSeconds)(this.startTime),
            end_time_unix_nano: this.endTime ? (0, utils_1.convertHrTimeToNanoSeconds)(this.endTime) : null,
            status: {
                code: this.status?.statusCode || span_status_1.SpanStatusCode.UNSET,
                message: this.status?.description
            },
            attributes: this.attributes || {},
            events: this.events.map((event) => ({
                name: event.name,
                time_unix_nano: event.timestamp,
                attributes: event.attributes || {}
            }))
        };
    }
    /**
     * Create a Span from JSON data (following Python implementation)
     * Converts the JSON data back into OpenTelemetry-compatible span
     */
    static fromJson(json) {
        // Convert the JSON data back to an OpenTelemetry-like span structure
        // This is simplified compared to Python but follows the same pattern
        const otelSpanData = {
            name: json.name,
            startTime: (0, utils_1.convertNanoSecondsToHrTime)(json.start_time_unix_nano),
            endTime: json.end_time_unix_nano ? (0, utils_1.convertNanoSecondsToHrTime)(json.end_time_unix_nano) : null,
            status: {
                code: convertStatusCodeToOTel(json.status.code),
                message: json.status.message
            },
            // For fromJson, attributes are already in their final form (not JSON serialized)
            // so we store them directly
            attributes: json.attributes || {},
            events: (json.events || []).map((event) => ({
                name: event.name,
                time: (0, utils_1.convertNanoSecondsToHrTime)(event.time_unix_nano),
                attributes: event.attributes || {}
            })),
            ended: true,
            // Add spanContext() method that returns proper SpanContext
            spanContext: () => ({
                traceId: (0, utils_1.decodeIdFromBase64)(json.trace_id),
                spanId: (0, utils_1.decodeIdFromBase64)(json.span_id),
                traceFlags: 1, // Sampled
                isRemote: false
            }),
            // Add parentSpanContext for parent span ID
            parentSpanContext: json.parent_span_id
                ? {
                    traceId: (0, utils_1.decodeIdFromBase64)(json.trace_id),
                    spanId: (0, utils_1.decodeIdFromBase64)(json.parent_span_id),
                    traceFlags: 1,
                    isRemote: false
                }
                : undefined
        };
        // Create a span that behaves like our Span class but from downloaded data
        return new Span(otelSpanData, false); // false = immutable
    }
}
exports.Span = Span;
/**
 * Convert MLflow status codes to OpenTelemetry status codes
 * @param statusCode Status code from MLflow JSON format
 * @returns OpenTelemetry compatible status code
 */
function convertStatusCodeToOTel(statusCode) {
    if (!statusCode) {
        return api_1.SpanStatusCode.UNSET;
    }
    // Handle MLflow format -> OTel format conversion
    switch (statusCode) {
        case 'STATUS_CODE_OK':
            return api_1.SpanStatusCode.OK;
        case 'STATUS_CODE_ERROR':
            return api_1.SpanStatusCode.ERROR;
        case 'STATUS_CODE_UNSET':
            return api_1.SpanStatusCode.UNSET;
        // Also handle OTel format directly
        case 'OK':
            return api_1.SpanStatusCode.OK;
        case 'ERROR':
            return api_1.SpanStatusCode.ERROR;
        case 'UNSET':
            return api_1.SpanStatusCode.UNSET;
        default:
            return api_1.SpanStatusCode.UNSET;
    }
}
class LiveSpan extends Span {
    constructor(span, traceId, span_type) {
        super(span, true);
        this.setAttribute(constants_1.SpanAttributeKey.TRACE_ID, traceId);
        this.setAttribute(constants_1.SpanAttributeKey.SPAN_TYPE, span_type);
    }
    /**
     * Set inputs for the span
     * @param inputs Input data for the span
     */
    setInputs(inputs) {
        this._attributesRegistry.set(constants_1.SpanAttributeKey.INPUTS, inputs);
    }
    /**
     * Set outputs for the span
     * @param outputs Output data for the span
     */
    setOutputs(outputs) {
        this._attributesRegistry.set(constants_1.SpanAttributeKey.OUTPUTS, outputs);
    }
    /**
     * Set an attribute on the span
     * @param key Attribute key
     * @param value Attribute value
     */
    setAttribute(key, value) {
        this._attributesRegistry.set(key, value);
    }
    /**
     * Set multiple attributes on the span
     * @param attributes Object containing key-value pairs for attributes
     */
    setAttributes(attributes) {
        if (!attributes || Object.keys(attributes).length === 0) {
            return;
        }
        Object.entries(attributes).forEach(([key, value]) => {
            this.setAttribute(key, value);
        });
    }
    /**
     * Add an event to the span
     * @param event Event object with name and attributes
     */
    addEvent(event) {
        // Convert BigInt timestamp to HrTime for OpenTelemetry
        const timeInput = (0, utils_1.convertNanoSecondsToHrTime)(event.timestamp);
        this._span.addEvent(event.name, event.attributes, timeInput);
    }
    /**
     * Record an exception event to the span
     * @param error Error object
     */
    recordException(error) {
        this._span.recordException(error);
    }
    /**
     * Set the status of the span
     * @param status Status code or SpanStatus object
     * @param description Optional description for the status
     */
    setStatus(status, description) {
        if (status instanceof span_status_1.SpanStatus) {
            this._span.setStatus(status.toOtelStatus());
        }
        else if (typeof status === 'string') {
            const spanStatus = new span_status_1.SpanStatus(status, description);
            this._span.setStatus(spanStatus.toOtelStatus());
        }
    }
    /**
     * End the span
     *
     * @param outputs Optional outputs to set before ending
     * @param attributes Optional attributes to set before ending
     * @param status Optional status code
     * @param endTimeNs Optional end time in nanoseconds
     */
    end(options) {
        try {
            if (options?.outputs != null) {
                this.setOutputs(options.outputs);
            }
            if (options?.attributes != null) {
                this.setAttributes(options.attributes);
            }
            if (options?.status != null) {
                this.setStatus(options.status);
            }
            // NB: In OpenTelemetry, status code remains UNSET if not explicitly set
            // by the user. However, there is not way to set the status when using
            // `trace` function wrapper. Therefore, we just automatically set the status
            // to OK if it is not ERROR.
            if (this.status.statusCode !== span_status_1.SpanStatusCode.ERROR) {
                this.setStatus(span_status_1.SpanStatusCode.OK);
            }
            // OTel SDK default end time to current time if not provided
            const endTime = options?.endTimeNs
                ? (0, utils_1.convertNanoSecondsToHrTime)(options.endTimeNs)
                : undefined;
            this._span.end(endTime);
            // Set the last active trace ID
            const traceManager = trace_manager_1.InMemoryTraceManager.getInstance();
            traceManager.lastActiveTraceId = this.traceId;
        }
        catch (error) {
            console.error(`Failed to end span ${this.spanId}: ${String(error)}.`);
        }
    }
}
exports.LiveSpan = LiveSpan;
/**
 * A no-operation span implementation that doesn't record anything
 */
class NoOpSpan {
    constructor(span) {
        // Create a minimal no-op span object
        this._span = span || {
            spanContext: () => ({
                spanId: api_1.INVALID_SPANID,
                traceId: api_1.INVALID_TRACEID
            }),
            attributes: {},
            events: []
        };
        this._attributesRegistry = new SpanAttributesRegistry(this._span);
    }
    get traceId() {
        return constants_1.NO_OP_SPAN_TRACE_ID;
    }
    get spanId() {
        return '';
    }
    get parentId() {
        return null;
    }
    get name() {
        return '';
    }
    get spanType() {
        return constants_1.SpanType.UNKNOWN;
    }
    get startTime() {
        return [0, 0];
    }
    get endTime() {
        return null;
    }
    get status() {
        return new span_status_1.SpanStatus(span_status_1.SpanStatusCode.UNSET);
    }
    get inputs() {
        return null;
    }
    get outputs() {
        return null;
    }
    get attributes() {
        return {};
    }
    getAttribute(_key) {
        return null;
    }
    // Implement all methods to do nothing
    setInputs(_inputs) { }
    setOutputs(_outputs) { }
    setAttribute(_key, _value) { }
    setAttributes(_attributes) { }
    setStatus(_status, _description) { }
    addEvent(_event) { }
    recordException(_error) { }
    end(_outputs, _attributes, _status, _endTimeNs) { }
    get events() {
        return [];
    }
    toJson() {
        return {
            trace_id: constants_1.NO_OP_SPAN_TRACE_ID,
            span_id: '',
            parent_span_id: '',
            name: '',
            start_time_unix_nano: 0n,
            end_time_unix_nano: null,
            status: { code: 'UNSET', message: '' },
            attributes: {},
            events: []
        };
    }
}
exports.NoOpSpan = NoOpSpan;
/**
 * A utility class to manage the span attributes.
 * In MLflow users can add arbitrary key-value pairs to the span attributes, however,
 * OpenTelemetry only allows a limited set of types to be stored in the attribute values.
 * Therefore, we serialize all values into JSON string before storing them in the span.
 * This class provides simple getter and setter methods to interact with the span attributes
 * without worrying about the serde process.
 */
class SpanAttributesRegistry {
    constructor(otelSpan) {
        this._span = otelSpan;
    }
    /**
     * Get all attributes as a dictionary
     */
    getAll() {
        const result = {};
        if (this._span.attributes) {
            Object.keys(this._span.attributes).forEach((key) => {
                result[key] = this.get(key);
            });
        }
        return result;
    }
    /**
     * Get a single attribute value
     */
    get(key) {
        const serializedValue = this._span.attributes?.[key];
        if (serializedValue && typeof serializedValue === 'string') {
            try {
                return JSON.parse(serializedValue);
            }
            catch (e) {
                // If JSON.parse fails, this might be a raw string value or
                // the span was created from JSON (attributes already parsed)
                // In that case, return the value as-is
                return serializedValue;
            }
        }
        return serializedValue;
    }
    /**
     * Set a single attribute value
     */
    set(key, value) {
        if (typeof key !== 'string') {
            console.warn(`Attribute key must be a string, but got ${typeof key}. Skipping.`);
            return;
        }
        // NB: OpenTelemetry attribute can store not only string but also a few primitives like
        // int, float, bool, and list of them. However, we serialize all into JSON string here
        // for the simplicity in deserialization process.
        this._span.setAttribute(key, (0, json_1.safeJsonStringify)(value));
    }
}
/**
 * A cache-enabled version of the SpanAttributesRegistry.
 * The caching helps to avoid the redundant deserialization of the attribute, however, it does
 * not handle the value change well. Therefore, this class should only be used for the persisted
 * spans that are immutable, and thus implemented as a subclass of SpanAttributesRegistry.
 */
class CachedSpanAttributesRegistry extends SpanAttributesRegistry {
    constructor() {
        super(...arguments);
        this._cache = new Map();
    }
    /**
     * Get a single attribute value with LRU caching (maxsize=128)
     */
    get(key) {
        if (this._cache.has(key)) {
            // Move to end (most recently used)
            const value = this._cache.get(key);
            this._cache.delete(key);
            this._cache.set(key, value);
            return value;
        }
        const value = super.get(key);
        // Implement LRU eviction
        if (this._cache.size >= 128) {
            // Remove least recently used (first entry)
            const firstKey = this._cache.keys().next().value;
            if (firstKey != null) {
                this._cache.delete(firstKey);
            }
        }
        this._cache.set(key, value);
        return value;
    }
    /**
     * Set operation is not allowed for cached registry (immutable spans)
     */
    set(_key, _value) {
        throw new Error('The attributes of the immutable span must not be updated.');
    }
}
/**
 * Factory function to create a span object.
 */
function createMlflowSpan(otelSpan, traceId, spanType) {
    // NonRecordingSpan always has a spanId of '0000000000000000'
    // https://github.com/open-telemetry/opentelemetry-js/blob/f2cfd1327a5b131ea795301b10877291aac4e6f5/api/src/trace/invalid-span-constants.ts#L23C32-L23C48
    /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-call */
    if (!otelSpan || otelSpan.spanContext().spanId === api_1.INVALID_SPANID) {
        return new NoOpSpan(otelSpan);
    }
    // If the span is completed, it should be immutable.
    if (otelSpan.ended) {
        return new Span(otelSpan);
    }
    return new LiveSpan(otelSpan, traceId, spanType || constants_1.SpanType.UNKNOWN);
    /* eslint-enable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-call */
}
