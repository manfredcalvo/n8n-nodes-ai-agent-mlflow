"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startSpan = startSpan;
exports.withSpan = withSpan;
exports.trace = trace;
exports.getLastActiveTraceId = getLastActiveTraceId;
exports.getCurrentActiveSpan = getCurrentActiveSpan;
exports.updateCurrentTrace = updateCurrentTrace;
const api_1 = require("@opentelemetry/api");
const constants_1 = require("./constants");
const span_1 = require("./entities/span");
const provider_1 = require("./provider");
const trace_manager_1 = require("./trace_manager");
const utils_1 = require("./utils");
const span_status_1 = require("./entities/span_status");
/**
 * Start a new span with the given name and span type.
 *
 * This function does NOT attach the created span to the current context. To create
 * nested spans, you need to set the parent span explicitly in the `parent` field.
 * The span must be ended by calling `end` method on the returned Span object.
 *
 * @param options Optional span options (name, spanType, inputs, attributes, startTimeNs, parent)
 * @returns The created span object.
 *
 * @example
 * ```typescript
 * const span = startSpan({
 *   name: 'my_span',
 *   spanType: 'LLM',
 *   inputs: {
 *     prompt: 'Hello, world!'
 *   }
 * });
 *
 * // Do something
 *
 * // End the span
 * span.end({
 *   status: 'OK',
 *   outputs: {
 *     response: 'Hello, world!'
 *   }
 * });
 * ```
 *
 */
function startSpan(options) {
    try {
        const tracer = (0, provider_1.getTracer)('default');
        // If parent is provided, use it as the parent spanAdd commentMore actions
        const parentContext = options.parent
            ? api_1.trace.setSpan(api_1.context.active(), options.parent._span)
            : api_1.context.active();
        // Convert startTimeNs to OTel format
        const startTime = options.startTimeNs
            ? (0, utils_1.convertNanoSecondsToHrTime)(options.startTimeNs)
            : undefined;
        const otelSpan = tracer.startSpan(options.name, { startTime: startTime }, parentContext);
        // Create and register the MLflow span
        const mlflowSpan = createAndRegisterMlflowSpan(otelSpan, options.spanType, options.inputs, options.attributes);
        return mlflowSpan;
    }
    catch (error) {
        console.warn('Failed to start span', error);
        return new span_1.NoOpSpan();
    }
}
/**
 * Execute a function within a span context. The span is automatically started before
 * the function executes and ended after it completes (or throws an error).
 *
 * This function uses OpenTelemetry's active span context to automatically manage
 * parent-child relationships between spans.
 *
 * This function supports two usage patterns:
 * 1. Inline: `withSpan((span) => { ... })` - span properties set within the callback
 * 2. Options: `withSpan((span) => { ... }, { name: 'test', ... })` - span properties set via options object
 *
 * @param callback The callback function to execute within the span context
 * @param options Optional span options (name, spanType, inputs, attributes, startTimeNs)
 * @returns The result of the callback function
 */
function withSpan(callback, options) {
    const spanOptions = options ?? { name: constants_1.DEFAULT_SPAN_NAME };
    // Generate a default span name if not provided
    const spanName = spanOptions.name || constants_1.DEFAULT_SPAN_NAME;
    const tracer = (0, provider_1.getTracer)('default');
    // Convert startTimeNs to OTel format if provided
    const startTime = spanOptions.startTimeNs
        ? (0, utils_1.convertNanoSecondsToHrTime)(spanOptions.startTimeNs)
        : undefined;
    // Use startActiveSpan to automatically manage context and parent-child relationships
    return tracer.startActiveSpan(spanName, { startTime }, (otelSpan) => {
        let mlflowSpan;
        try {
            // Create and register the MLflow span
            mlflowSpan = createAndRegisterMlflowSpan(otelSpan, spanOptions.spanType, spanOptions.inputs, spanOptions.attributes);
        }
        catch (error) {
            console.debug('Failed to create and register MLflow span', error);
            mlflowSpan = new span_1.NoOpSpan();
        }
        // Expression function to handle errors consistently
        const handleError = (error) => {
            try {
                mlflowSpan.setStatus(span_status_1.SpanStatusCode.ERROR, error.message);
                mlflowSpan.recordException(error);
                mlflowSpan.end();
            }
            catch (error) {
                console.debug('Failed to set status or record exception on MLflow span', error);
            }
            throw error;
        };
        try {
            // Execute the callback with the span
            const result = callback(mlflowSpan);
            // Handle both sync and async results
            if (result instanceof Promise) {
                return result
                    .then((value) => {
                    // Set outputs if they are not already set
                    if (mlflowSpan.outputs === undefined) {
                        mlflowSpan.setOutputs(value);
                    }
                    mlflowSpan.end();
                    return value;
                })
                    .catch(handleError);
            }
            else {
                // Synchronous execution
                if (mlflowSpan.outputs === undefined) {
                    mlflowSpan.setOutputs(result);
                }
                mlflowSpan.end();
                return result;
            }
        }
        catch (error) {
            // Handle synchronous errors
            return handleError(error);
        }
    });
}
/**
 * Helper function to create and register an MLflow span from an OpenTelemetry span
 * @param otelSpan The OpenTelemetry span
 * @param spanType The MLflow span type
 * @param inputs Optional inputs to set on the span
 * @param attributes Optional attributes to set on the span
 * @returns The created and registered MLflow LiveSpan
 */
function createAndRegisterMlflowSpan(otelSpan, spanType, inputs, attributes) {
    // Get the MLflow trace ID from the OpenTelemetry trace ID
    const otelTraceId = otelSpan.spanContext().traceId;
    const traceId = trace_manager_1.InMemoryTraceManager.getInstance().getMlflowTraceIdFromOtelId(otelTraceId) || otelTraceId;
    // Create the MLflow span from the OTel span
    const mlflowSpan = (0, span_1.createMlflowSpan)(otelSpan, traceId, spanType);
    // Set initial properties if provided
    if (inputs) {
        mlflowSpan.setInputs(inputs);
    }
    if (attributes) {
        mlflowSpan.setAttributes(attributes);
    }
    // Register the span with the trace manager
    const traceManager = trace_manager_1.InMemoryTraceManager.getInstance();
    traceManager.registerSpan(mlflowSpan);
    return mlflowSpan;
}
function trace(funcOrOptions, options) {
    // Check if this is being used as a decorator (no function provided, or options provided)
    if (typeof funcOrOptions !== 'function') {
        const decoratorOptions = funcOrOptions;
        // Return a method decorator that supports both old and new TypeScript decorator syntax
        return function (...args) {
            let originalMethod;
            let methodName;
            // Check if using new TypeScript 5.0+ decorator syntax
            const isNewSyntax = args.length === 2 && typeof args[1] === 'object' && !Array.isArray(args[1]);
            if (isNewSyntax) {
                // New syntax: (originalMethod, context)
                originalMethod = args[0];
                const context = args[1];
                methodName = String(context.name);
            }
            else {
                // Old syntax: (target, propertyKey, descriptor)
                const desc = args[2];
                originalMethod = desc.value;
                methodName = String(args[1]);
            }
            // Create the traced method wrapper
            const tracedMethod = function (...args) {
                let inputs;
                try {
                    inputs = (0, utils_1.mapArgsToObject)(originalMethod, args);
                }
                catch (error) {
                    console.debug('Failed to map arguments values to names', error);
                    inputs = args;
                }
                const spanOptions = {
                    name: decoratorOptions?.name || originalMethod.name || methodName,
                    spanType: decoratorOptions?.spanType,
                    attributes: decoratorOptions?.attributes,
                    inputs
                };
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return withSpan((_span) => {
                    // Call the original method with the preserved `this` context
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return originalMethod.apply(this, args);
                }, spanOptions);
            };
            // Return the appropriate value based on the decorator syntax
            if (isNewSyntax) {
                return tracedMethod;
            }
            else {
                const descriptor = args[2];
                descriptor.value = tracedMethod;
                // Preserve the original method's properties
                Object.defineProperty(descriptor.value, 'length', { value: originalMethod.length });
                Object.defineProperty(descriptor.value, 'name', { value: originalMethod.name });
                return descriptor;
            }
        };
    }
    else {
        // This is the function-based usage (existing behavior)
        return traceFunction(funcOrOptions, options);
    }
}
/**
 * Internal function to handle function-based tracing (non-decorator usage)
 */
function traceFunction(func, options) {
    // Create a wrapper function that preserves the original function's properties
    const wrapper = function (...args) {
        let inputs;
        try {
            inputs = (0, utils_1.mapArgsToObject)(func, args);
        }
        catch (error) {
            console.debug('Failed to map arguments values to names', error);
            inputs = args;
        }
        const spanOptions = {
            name: options?.name || func.name || constants_1.DEFAULT_SPAN_NAME,
            spanType: options?.spanType,
            attributes: options?.attributes,
            inputs: inputs
        };
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return withSpan((_span) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return func.apply(this, args);
        }, spanOptions);
    };
    // Preserve function properties
    Object.defineProperty(wrapper, 'length', { value: func.length });
    Object.defineProperty(wrapper, 'name', { value: func.name });
    // Copy any additional properties from the original function
    for (const prop in func) {
        if (Object.prototype.hasOwnProperty.call(func, prop)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            wrapper[prop] = func[prop];
        }
    }
    return wrapper;
}
/**
 * Get the last active trace ID.
 * @returns The last active trace ID.
 */
function getLastActiveTraceId() {
    const traceManager = trace_manager_1.InMemoryTraceManager.getInstance();
    return traceManager.lastActiveTraceId;
}
/**
 * Get the current active span in the global context.
 *
 * This only works when the span is created with fluent APIs like `@trace` or
 * `withSpan`. If a span is created with the `startSpan` API, it won't be
 * attached to the global context so this function will not return it.
 *
 * @returns The current active span if exists, otherwise null.
 *
 * @example
 * ```typescript
 * const tracedFunc = trace(() => {
 *   const span = getCurrentActiveSpan();
 *   span?.setAttribute("key", "value");
 *   return 0;
 * });
 *
 * tracedFunc();
 * ```
 */
function getCurrentActiveSpan() {
    const otelSpan = api_1.trace.getActiveSpan();
    // If no active span or it's a NonRecordingSpan, return undefined
    if (!otelSpan || otelSpan.spanContext().traceId === api_1.INVALID_TRACEID) {
        return null;
    }
    const traceManager = trace_manager_1.InMemoryTraceManager.getInstance();
    const otelTraceId = otelSpan.spanContext().traceId;
    const mlflowTraceId = traceManager.getMlflowTraceIdFromOtelId(otelTraceId);
    if (!mlflowTraceId) {
        return null;
    }
    const spanId = otelSpan.spanContext().spanId;
    return traceManager.getSpan(mlflowTraceId, spanId) || null;
}
/**
 * Update the current active trace with the given options.
 *
 * You can use this function either within a function decorated with `@trace` or
 * within the scope of the `withSpan` context. If there is no active trace found,
 * this function will log a warning and return.
 *
 * @param options Options for updating the trace
 *
 * @example
 * Using within a function decorated with `@trace`:
 * ```typescript
 * const myFunc = trace((x: number) => {
 *   updateCurrentTrace({ tags: { fruit: "apple" }, clientRequestId: "req-12345" });
 *   return x + 1;
 * });
 * ```
 *
 * @example
 * Using within the `withSpan` context:
 * ```typescript
 * withSpan((span) => {
 *   updateCurrentTrace({ tags: { fruit: "apple" }, clientRequestId: "req-12345" });
 * }, { name: "span" });
 * ```
 *
 * @example
 * Updating source information of the trace:
 * ```typescript
 * updateCurrentTrace({
 *   metadata: {
 *     "mlflow.trace.session": "session-4f855da00427",
 *     "mlflow.trace.user": "user-id-cc156f29bcfb",
 *     "mlflow.source.name": "inference.ts",
 *     "mlflow.source.git.commit": "1234567890",
 *     "mlflow.source.git.repoURL": "https://github.com/mlflow/mlflow"
 *   }
 * });
 * ```
 */
function updateCurrentTrace({ tags, metadata, clientRequestId, requestPreview, responsePreview }) {
    const activeSpan = getCurrentActiveSpan();
    if (!activeSpan) {
        console.warn('No active trace found. Please create a span using `withSpan` or ' +
            '`@trace` before calling `updateCurrentTrace`.');
        return;
    }
    // Validate string parameters
    if (requestPreview !== undefined && typeof requestPreview !== 'string') {
        throw new Error('The `requestPreview` parameter must be a string.');
    }
    if (responsePreview !== undefined && typeof responsePreview !== 'string') {
        throw new Error('The `responsePreview` parameter must be a string.');
    }
    // Update trace info for the trace stored in-memory
    const traceManager = trace_manager_1.InMemoryTraceManager.getInstance();
    const trace = traceManager.getTrace(activeSpan.traceId);
    if (!trace) {
        console.warn(`Trace ${activeSpan.traceId} does not exist or already finished.`);
        return;
    }
    // Update trace info properties
    if (requestPreview !== undefined) {
        trace.info.requestPreview = requestPreview;
    }
    if (responsePreview !== undefined) {
        trace.info.responsePreview = responsePreview;
    }
    if (tags !== undefined) {
        Object.assign(trace.info.tags, tags);
    }
    if (metadata !== undefined) {
        Object.assign(trace.info.traceMetadata, metadata);
    }
    if (clientRequestId !== undefined) {
        trace.info.clientRequestId = String(clientRequestId);
    }
}
