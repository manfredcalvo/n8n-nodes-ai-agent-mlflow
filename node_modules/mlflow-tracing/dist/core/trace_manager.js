"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryTraceManager = void 0;
const trace_1 = require("./entities/trace");
const trace_data_1 = require("./entities/trace_data");
const constants_1 = require("./constants");
/**
 * Internal representation to keep the state of a trace.
 * Uses a Map<string, LiveSpan> instead of TraceData to allow access by span_id.
 */
class _Trace {
    constructor(info) {
        this.info = info;
        this.spanDict = new Map();
    }
    /**
     * Convert the internal trace representation to an MLflow Trace object
     */
    toMlflowTrace() {
        // Convert LiveSpan, mutable objects, into immutable Span objects before persisting
        const traceData = new trace_data_1.TraceData([...this.spanDict.values()]);
        const root_span = traceData.spans.find((span) => span.parentId == null);
        if (root_span) {
            // Accessing the OTel span directly get serialized value directly.
            // TODO: Implement the smart truncation logic.
            // Only set previews if they haven't been explicitly set by updateCurrentTrace
            if (!this.info.requestPreview) {
                this.info.requestPreview = getPreviewString(root_span._span.attributes[constants_1.SpanAttributeKey.INPUTS]);
            }
            if (!this.info.responsePreview) {
                this.info.responsePreview = getPreviewString(root_span._span.attributes[constants_1.SpanAttributeKey.OUTPUTS]);
            }
            // TODO: Remove this once the new trace table UI is available that is based on MLflow V3 trace.
            // Until then, these two metadata are still used to render the "request" and "response" columns.
            this.info.traceMetadata[constants_1.TraceMetadataKey.INPUTS] = this.info.requestPreview;
            this.info.traceMetadata[constants_1.TraceMetadataKey.OUTPUTS] = this.info.responsePreview;
        }
        return new trace_1.Trace(this.info, traceData);
    }
}
function getPreviewString(inputsOrOutputs) {
    if (!inputsOrOutputs) {
        return '';
    }
    if (inputsOrOutputs.length > constants_1.REQUEST_RESPONSE_PREVIEW_MAX_LENGTH) {
        return inputsOrOutputs.slice(0, constants_1.REQUEST_RESPONSE_PREVIEW_MAX_LENGTH - 3) + '...';
    }
    return inputsOrOutputs;
}
/**
 * Manage spans and traces created by the tracing system in memory.
 * This class is implemented as a singleton.
 */
class InMemoryTraceManager {
    /**
     * Singleton pattern implementation
     */
    static getInstance() {
        if (InMemoryTraceManager._instance == null) {
            InMemoryTraceManager._instance = new InMemoryTraceManager();
        }
        return InMemoryTraceManager._instance;
    }
    constructor() {
        this._traces = new Map();
        this._otelIdToMlflowTraceId = new Map();
    }
    /**
     * Register a new trace info object to the in-memory trace registry.
     * @param otelTraceId The OpenTelemetry trace ID for the new trace
     * @param traceInfo The trace info object to be stored
     */
    registerTrace(otelTraceId, traceInfo) {
        this._traces.set(traceInfo.traceId, new _Trace(traceInfo));
        this._otelIdToMlflowTraceId.set(otelTraceId, traceInfo.traceId);
    }
    /**
     * Store the given span in the in-memory trace data.
     * @param span The span to be stored
     */
    registerSpan(span) {
        const trace = this._traces.get(span.traceId);
        if (trace) {
            trace.spanDict.set(span.spanId, span);
        }
        else {
            console.debug(`Tried to register span ${span.spanId} for trace ${span.traceId}
                     but trace not found. Please make sure to register the trace first.`);
        }
    }
    /**
     * Get the trace for the given trace ID.
     * Returns the trace object or null if not found.
     * @param traceId The trace ID to look up
     */
    getTrace(traceId) {
        return this._traces.get(traceId) || null;
    }
    /**
     * Get the MLflow trace ID for the given OpenTelemetry trace ID.
     * @param otelTraceId The OpenTelemetry trace ID
     */
    getMlflowTraceIdFromOtelId(otelTraceId) {
        return this._otelIdToMlflowTraceId.get(otelTraceId) || null;
    }
    /**
     * Get the span for the given trace ID and span ID.
     * @param traceId The trace ID
     * @param spanId The span ID
     */
    getSpan(traceId, spanId) {
        return this._traces.get(traceId)?.spanDict.get(spanId) || null;
    }
    /**
     * Pop trace data for the given OpenTelemetry trace ID and return it as
     * a ready-to-publish Trace object.
     * @param otelTraceId The OpenTelemetry trace ID
     */
    popTrace(otelTraceId) {
        const mlflowTraceId = this._otelIdToMlflowTraceId.get(otelTraceId);
        if (!mlflowTraceId) {
            console.debug(`Tried to pop trace ${otelTraceId} but no trace found.`);
            return null;
        }
        this._otelIdToMlflowTraceId.delete(otelTraceId);
        const trace = this._traces.get(mlflowTraceId);
        if (trace) {
            this._traces.delete(mlflowTraceId);
            return trace.toMlflowTrace();
        }
        console.debug(`Tried to pop trace ${otelTraceId} but trace not found.`);
        return null;
    }
    /**
     * Clear all the aggregated trace data. This should only be used for testing.
     */
    static reset() {
        if (InMemoryTraceManager._instance) {
            InMemoryTraceManager._instance._traces.clear();
            InMemoryTraceManager._instance._otelIdToMlflowTraceId.clear();
            InMemoryTraceManager._instance = undefined;
        }
    }
}
exports.InMemoryTraceManager = InMemoryTraceManager;
