"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequestHeaders = getRequestHeaders;
exports.makeRequest = makeRequest;
const json_1 = require("../core/utils/json");
/**
 * Get the request headers for the given token.
 *
 * @param token - The token to use to authenticate the request.
 * @returns The request headers.
 */
function getRequestHeaders(token) {
    const headers = { 'Content-Type': 'application/json' };
    if (token) {
        headers['Authorization'] = `Bearer ${token}`;
    }
    return headers;
}
/**
 * Make a request to the given URL with the given method, headers, body, and timeout.
 *
 * TODO: add retry logic for transient errors
 */
async function makeRequest(method, url, headers, body, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout ?? getDefaultTimeout());
    try {
        const response = await fetch(url, {
            method,
            headers: headers,
            body: body ? json_1.JSONBig.stringify(body) : undefined,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        // Handle empty responses (like DELETE operations)
        if (response.status === 204 || response.headers.get('content-length') === '0') {
            return {};
        }
        const responseText = await response.text();
        return json_1.JSONBig.parse(responseText);
    }
    catch (error) {
        clearTimeout(timeoutId);
        if (error instanceof Error) {
            if (error.name === 'AbortError') {
                throw new Error(`Request timeout after ${timeout}ms`);
            }
            throw new Error(`API request failed: ${error.message}`);
        }
        throw new Error(`API request failed: ${String(error)}`);
    }
}
function getDefaultTimeout() {
    const envTimeout = process.env.MLFLOW_HTTP_REQUEST_TIMEOUT;
    if (envTimeout) {
        const timeout = parseInt(envTimeout, 10);
        if (!isNaN(timeout) && timeout > 0) {
            return timeout;
        }
    }
    return 30000; // Default 30 seconds
}
