"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MlflowClient = void 0;
const trace_info_1 = require("../core/entities/trace_info");
const trace_1 = require("../core/entities/trace");
const spec_1 = require("./spec");
const utils_1 = require("./utils");
const artifacts_1 = require("./artifacts");
/**
 * Client for MLflow tracing operations
 */
class MlflowClient {
    constructor(options) {
        this.host = options.host;
        this.databricksToken = options.databricksToken;
        this.artifactsClient = (0, artifacts_1.getArtifactsClient)({
            trackingUri: options.trackingUri,
            host: options.host,
            databricksToken: options.databricksToken
        });
    }
    // === TRACE LOGGING METHODS ===
    /**
     * Create a new TraceInfo record in the backend store.
     * Corresponding to the Python SDK's start_trace_v3() method.
     *
     * Note: the backend API is named as "Start" due to unfortunate miscommunication.
     * The API is indeed called at the "end" of a trace, not the "start".
     */
    async createTrace(traceInfo) {
        const url = spec_1.StartTraceV3.getEndpoint(this.host);
        const payload = { trace: { trace_info: traceInfo.toJson() } };
        const response = await (0, utils_1.makeRequest)('POST', url, (0, utils_1.getRequestHeaders)(this.databricksToken), payload);
        return trace_info_1.TraceInfo.fromJson(response.trace.trace_info);
    }
    // === TRACE RETRIEVAL METHODS ===
    /**
     * Get a single trace by ID
     * Fetches both trace info and trace data from backend
     * Corresponds to Python: client.get_trace()
     */
    async getTrace(traceId) {
        const traceInfo = await this.getTraceInfo(traceId);
        const traceData = await this.artifactsClient.downloadTraceData(traceInfo);
        return new trace_1.Trace(traceInfo, traceData);
    }
    /**
     * Get trace info using V3 API
     * Endpoint: GET /api/3.0/mlflow/traces/{trace_id}
     */
    async getTraceInfo(traceId) {
        const url = spec_1.GetTraceInfoV3.getEndpoint(this.host, traceId);
        const response = await (0, utils_1.makeRequest)('GET', url, (0, utils_1.getRequestHeaders)(this.databricksToken));
        // The V3 API returns a Trace object with trace_info field
        if (response.trace?.trace_info) {
            return trace_info_1.TraceInfo.fromJson(response.trace.trace_info);
        }
        throw new Error(`Invalid response format: missing trace_info: ${JSON.stringify(response)}`);
    }
    /**
     * Upload trace data to the artifact store.
     */
    async uploadTraceData(traceInfo, traceData) {
        await this.artifactsClient.uploadTraceData(traceInfo, traceData);
    }
    // === EXPERIMENT METHODS  ===
    /**
     * Create a new experiment
     */
    async createExperiment(name, artifactLocation, tags) {
        const url = spec_1.CreateExperiment.getEndpoint(this.host);
        const payload = { name, artifact_location: artifactLocation, tags };
        const response = await (0, utils_1.makeRequest)('POST', url, (0, utils_1.getRequestHeaders)(this.databricksToken), payload);
        return response.experiment_id;
    }
    /**
     * Delete an experiment
     */
    async deleteExperiment(experimentId) {
        const url = spec_1.DeleteExperiment.getEndpoint(this.host);
        const payload = { experiment_id: experimentId };
        await (0, utils_1.makeRequest)('POST', url, (0, utils_1.getRequestHeaders)(this.databricksToken), payload);
    }
}
exports.MlflowClient = MlflowClient;
