"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MlflowSpanExporter = exports.MlflowSpanProcessor = void 0;
const trace_manager_1 = require("../core/trace_manager");
const trace_info_1 = require("../core/entities/trace_info");
const trace_location_1 = require("../core/entities/trace_location");
const trace_state_1 = require("../core/entities/trace_state");
const constants_1 = require("../core/constants");
const utils_1 = require("../core/utils");
const config_1 = require("../core/config");
/**
 * Generate a MLflow-compatible trace ID for the given span.
 * @param span The span to generate the trace ID for
 */
function generateTraceId(span) {
    // NB: trace Id is already hex string in Typescript OpenTelemetry SDK
    return constants_1.TRACE_ID_PREFIX + span.spanContext().traceId;
}
class MlflowSpanProcessor {
    constructor(exporter) {
        this._exporter = exporter;
    }
    /**
     * Called when a {@link Span} is started, if the `span.isRecording()`
     * returns true.
     * @param span the Span that just started.
     */
    onStart(span, _parentContext) {
        const otelTraceId = span.spanContext().traceId;
        let traceId;
        const experimentId = (0, config_1.getConfig)().experimentId;
        if (!span.parentSpanContext?.spanId) {
            // This is a root span
            traceId = generateTraceId(span);
            const trace_info = new trace_info_1.TraceInfo({
                traceId: traceId,
                traceLocation: (0, trace_location_1.createTraceLocationFromExperimentId)(experimentId),
                requestTime: (0, utils_1.convertHrTimeToMs)(span.startTime),
                executionDuration: 0,
                state: trace_state_1.TraceState.IN_PROGRESS,
                traceMetadata: {},
                tags: {},
                assessments: []
            });
            trace_manager_1.InMemoryTraceManager.getInstance().registerTrace(otelTraceId, trace_info);
        }
        else {
            traceId = trace_manager_1.InMemoryTraceManager.getInstance().getMlflowTraceIdFromOtelId(otelTraceId) || '';
            if (!traceId) {
                console.warn(`No trace ID found for span ${span.name}. Skipping.`);
                return;
            }
        }
        // Set trace ID to the span
        span.setAttribute(constants_1.SpanAttributeKey.TRACE_ID, JSON.stringify(traceId));
    }
    /**
     * Called when a {@link ReadableSpan} is ended, if the `span.isRecording()`
     * returns true.
     * @param span the Span that just ended.
     */
    onEnd(span) {
        // Only trigger trace export for root span completion
        if (span.parentSpanContext?.spanId) {
            return;
        }
        // Update trace info
        const otelTraceId = span.spanContext().traceId;
        const traceId = trace_manager_1.InMemoryTraceManager.getInstance().getMlflowTraceIdFromOtelId(otelTraceId);
        if (!traceId) {
            console.warn(`No trace ID found for span ${span.name}. Skipping.`);
            return;
        }
        const trace = trace_manager_1.InMemoryTraceManager.getInstance().getTrace(traceId);
        if (!trace) {
            console.warn(`No trace found for span ${span.name}. Skipping.`);
            return;
        }
        this.updateTraceInfo(trace.info, span);
        (0, utils_1.deduplicateSpanNamesInPlace)(Array.from(trace.spanDict.values()));
        // Aggregate token usage from all spans and add to trace metadata
        const allSpans = Array.from(trace.spanDict.values());
        const aggregatedUsage = (0, utils_1.aggregateUsageFromSpans)(allSpans);
        if (aggregatedUsage) {
            trace.info.traceMetadata[constants_1.TraceMetadataKey.TOKEN_USAGE] = JSON.stringify(aggregatedUsage);
        }
        this._exporter.export([span], (_) => { });
    }
    /**
     * Update the trace info with the span end time and status.
     * @param trace The trace to update
     * @param span The span to update the trace with
     */
    updateTraceInfo(traceInfo, span) {
        traceInfo.executionDuration = (0, utils_1.convertHrTimeToMs)(span.endTime) - traceInfo.requestTime;
        traceInfo.state = (0, trace_state_1.fromOtelStatus)(span.status.code);
    }
    /**
     * Shuts down the processor. Called when SDK is shut down. This is an
     * opportunity for processor to do any cleanup required.
     */
    async shutdown() {
        await this._exporter.shutdown();
    }
    /**
     * Forces to export all finished spans
     */
    async forceFlush() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        await this._exporter.forceFlush();
    }
}
exports.MlflowSpanProcessor = MlflowSpanProcessor;
class MlflowSpanExporter {
    constructor(client) {
        this._pendingExports = {}; // traceId -> export promise
        this._client = client;
    }
    export(spans, _resultCallback) {
        for (const span of spans) {
            // Only export root spans
            if (span.parentSpanContext?.spanId) {
                continue;
            }
            const trace = trace_manager_1.InMemoryTraceManager.getInstance().popTrace(span.spanContext().traceId);
            if (!trace) {
                console.warn(`No trace found for span ${span.name}. Skipping.`);
                continue;
            }
            // Export trace to backend and track the promise
            const exportPromise = this.exportTraceToBackend(trace).catch((error) => {
                console.error(`Failed to export trace ${trace.info.traceId}:`, error);
            });
            this._pendingExports[trace.info.traceId] = exportPromise;
        }
    }
    /**
     * Export a complete trace to the MLflow backend
     * Step 1: Create trace metadata via StartTraceV3 endpoint
     * Step 2: Upload trace data (spans) via artifact repository pattern
     */
    async exportTraceToBackend(trace) {
        try {
            // Step 1: Create trace metadata in backend
            const traceInfo = await this._client.createTrace(trace.info);
            // Step 2: Upload trace data (spans) to artifact storage
            await this._client.uploadTraceData(traceInfo, trace.data);
        }
        catch (error) {
            console.error(`Failed to export trace ${trace.info.traceId}:`, error);
            throw error;
        }
        finally {
            // Remove the promise from the pending exports
            delete this._pendingExports[trace.info.traceId];
        }
    }
    /**
     * Force flush all pending trace exports.
     * Waits for all async export operations to complete.
     */
    async forceFlush() {
        await Promise.all(Object.values(this._pendingExports));
        this._pendingExports = {};
    }
    /**
     * Shutdown the exporter.
     * Waits for all pending exports to complete before shutting down.
     */
    async shutdown() {
        await this.forceFlush();
    }
}
exports.MlflowSpanExporter = MlflowSpanExporter;
